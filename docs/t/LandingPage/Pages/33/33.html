<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Energy Dashboard</title>
    <link rel="stylesheet" href="33.css">
</head>
<body>
    <div class="page-container page33-scope">
        <div class="content-wrapper">
            <!-- 标题区域 -->
            <div class="header-section">
                <div class="title-section">
                    <div class="red-rectangle"></div>
                    <div class="title-texts">
                        <h2 class="subtitle">User App</h2>
                        <h1 class="main-title">Energy Dashboard</h1>
                    </div>
                </div>
            </div>
            
            <!-- 正文区域 -->
            <div class="content-area">
                <div class="description-text">
                    <p>The Elecq App provides real-time, intuitive displays of charging information and the overall status of home energy systems, allowing users to configure and control the charging stations seamlessly.
                    </p>
                </div>
                <!-- 中央图片区域 -->
                <div class="centered-image-container">
                    <img src="res/energyboard.png" alt="Edge Device" class="centered-image">
                </div>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', function() {

    function debounce(func, delay) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), delay);
        };
    }

    const image = document.querySelector('.page33-scope .centered-image');
    const pageContainer = document.querySelector('.page33-scope.page-container');
    const contentWrapper = document.querySelector('.page33-scope .content-wrapper');

    let initialRenderedWidth = 0;
    let initialRenderedHeight = 0;
    let baseTransformValue = 'translateZ(0px)';

    function updateImageBaseState() {
        if (!image) return;
        // Temporarily remove inline transform to measure CSS-defined size accurately
        const currentInlineTransform = image.style.transform;
        image.style.transform = ''; // Reset to allow CSS to dictate size

        initialRenderedWidth = image.offsetWidth;
        initialRenderedHeight = image.offsetHeight;

        baseTransformValue = getComputedStyle(image).transform;
        if (baseTransformValue === 'none' || baseTransformValue === '') {
            baseTransformValue = 'translateZ(0px)';
        }
        // Restore original inline transform if it wasn't the base one, or apply new base
        // This logic is tricky. Simpler: always set to the new baseTransformValue.
        image.style.transform = baseTransformValue;
    }

    if (image && pageContainer && contentWrapper) {
        updateImageBaseState(); // Initial setup

        window.addEventListener('resize', debounce(updateImageBaseState, 250)); // Update on resize

        image.addEventListener('mouseenter', function() {
            const pageContainerHeight = pageContainer.clientHeight;
            const contentWrapperWidth = contentWrapper.clientWidth;

            // Use initialRenderedWidth and initialRenderedHeight captured outside this event listener
            // These represent the dimensions of the image as initially displayed (e.g., by 'width: 20%')
            // Get current top of the image relative to the viewport
            const imageRect = image.getBoundingClientRect();
            const pageContainerRect = pageContainer.getBoundingClientRect();
            
            // Calculate the image's current top position relative to the pageContainer's top.
            // This is the visual offset before the hover transform is applied.
            const initialImageTopMargin = imageRect.top - pageContainerRect.top;

            if (initialRenderedWidth === 0 || initialRenderedHeight === 0) {
                return;
            }

            let scaleFactor = 1;
            // Calculate scale needed to make current rendered height match pageContainerHeight
            const scaleToFitHeight = pageContainerHeight / initialRenderedHeight;
            // Calculate scale needed to make current rendered width match contentWrapperWidth
            const scaleToFitWidth = contentWrapperWidth / initialRenderedWidth;
            

            scaleFactor = Math.min(scaleToFitHeight, scaleToFitWidth);
            
            if (scaleFactor <= 0 || !isFinite(scaleFactor)) {
                scaleFactor = 1;
            }

            // The final display size will be initialRendered * scaleFactor
            const finalWidth = initialRenderedWidth * scaleFactor;
            const finalHeight = initialRenderedHeight * scaleFactor;
            
            // Calculate translateY
            // Target: scaled image's top should be at ((pageContainerHeight - finalHeight) / 2) from pageContainer's top
            // The image scales from its own top edge due to 'transform-origin: top center'.
            // So, its new visual top, *without* any translateY, would be at 'initialImageTopMargin'.
            // We want its new visual top to be at 'targetTopPositionInContainer'.
            const targetTopPositionInContainer = (pageContainerHeight - finalHeight) / 2;
            let translateYValue = targetTopPositionInContainer - initialImageTopMargin;

            // Safety: if targetTopPositionInContainer is negative (e.g. image taller than container), cap at 0 or handle as needed.
            // For now, we assume it fits or aligns top.
            if (finalHeight >= pageContainerHeight) { // If image fills or exceeds container height, align its top with container top
                translateYValue = -initialImageTopMargin; 
            }


            const newTransform = `translateY(${translateYValue.toFixed(2)}px) translateZ(0px) scale(${scaleFactor.toFixed(4)})`;
            image.style.transform = newTransform;
        });

        image.addEventListener('mouseleave', function() {
            // baseTransformValue should ideally not contain a scale from a previous hover if this is a fresh mouseleave.
            // It should be the state set on DOMContentLoaded or from CSS.
            // The current 'baseTransformValue' is correct as it's set once initially.
            image.style.transform = baseTransformValue;
        });
    } else {
        console.error('Required elements (image, pageContainer, or contentWrapper) not found.');
    }
});
</script>
</body>
</html>
